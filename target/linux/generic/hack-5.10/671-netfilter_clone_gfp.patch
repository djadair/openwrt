netfilter:nf_tables  Allow non-atomic counter creation.

Add gfp flag to expression clone operations so that table creation
operations can use non-atomic kmalloc, percpu_alloc while GFP_ATOMIC
remains available for dynamic manipulation.

This corrects ENOBUFS / ENOMEM errors when nft is used to create
or refresh large sets using counters.  Because percpu uses dynamic
allocation triggered by a FAILURE of atomic allocations there is always
some set size guaranteed not to work because it exceeds the available
fragmented space + PCPU_EMPTY_POP_PAGES_LOW.  The main netlink api
creation functions do not require GFP_ATOMIC since several other
allocations are GFP_KERNEL anyway.

Signed-off-by: David Adair  <djabhead@aol.com>

--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -800,7 +800,8 @@ struct nft_expr_ops {
 						struct nft_regs *regs,
 						const struct nft_pktinfo *pkt);
 	int				(*clone)(struct nft_expr *dst,
-						 const struct nft_expr *src);
+						 const struct nft_expr *src,
+						 gfp_t gfp);
 	unsigned int			size;
 
 	int				(*init)(const struct nft_ctx *ctx,
@@ -851,7 +852,12 @@ static inline void *nft_expr_priv(const
 	return (void *)expr->data;
 }
 
-int nft_expr_clone(struct nft_expr *dst, struct nft_expr *src);
+/* Assume atomic for ops without GFP, suitable for data path */
+int nft_expr_clone_gfp(struct nft_expr *dst, struct nft_expr *src, gfp_t gfp);
+static inline int nft_expr_clone(struct nft_expr *dst, struct nft_expr *src)
+{
+	return nft_expr_clone_gfp(dst, src, GFP_ATOMIC);
+}
 void nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr);
 int nft_expr_dump(struct sk_buff *skb, unsigned int attr,
 		  const struct nft_expr *expr);
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -2711,13 +2711,14 @@ err_expr_parse:
 	return ERR_PTR(err);
 }
 
-int nft_expr_clone(struct nft_expr *dst, struct nft_expr *src)
+int nft_expr_clone_gfp(struct nft_expr *dst, struct nft_expr *src,
+		       gfp_t gfp)
 {
 	int err;
 
 	if (src->ops->clone) {
 		dst->ops = src->ops;
-		err = src->ops->clone(dst, src);
+		err = src->ops->clone(dst, src, gfp);
 		if (err < 0)
 			return err;
 	} else {
@@ -5187,7 +5188,7 @@ static int nft_set_elem_expr_setup(struc
 	if (expr == NULL)
 		return 0;
 
-	err = nft_expr_clone(elem_expr, expr);
+	err = nft_expr_clone_gfp(elem_expr, expr, GFP_KERNEL);
 	if (err < 0)
 		return -ENOMEM;
 
@@ -5286,7 +5287,7 @@ static int nft_add_set_elem(struct nft_c
 		if (!expr)
 			return -ENOMEM;
 
-		err = nft_expr_clone(expr, set->expr);
+		err = nft_expr_clone_gfp(expr, set->expr, GFP_KERNEL);
 		if (err < 0) {
 			kfree(expr);
 			expr = null;
--- a/net/netfilter/nft_connlimit.c
+++ b/net/netfilter/nft_connlimit.c
@@ -195,7 +195,8 @@ static void nft_connlimit_destroy(const
 	nft_connlimit_do_destroy(ctx, priv);
 }
 
-static int nft_connlimit_clone(struct nft_expr *dst, const struct nft_expr *src)
+static int nft_connlimit_clone(struct nft_expr *dst, const struct nft_expr *src,
+			       gfp_t gfp)
 {
 	struct nft_connlimit *priv_dst = nft_expr_priv(dst);
 	struct nft_connlimit *priv_src = nft_expr_priv(src);
--- a/net/netfilter/nft_counter.c
+++ b/net/netfilter/nft_counter.c
@@ -224,7 +224,8 @@ static void nft_counter_destroy(const st
 	nft_counter_do_destroy(priv);
 }
 
-static int nft_counter_clone(struct nft_expr *dst, const struct nft_expr *src)
+static int nft_counter_clone(struct nft_expr *dst, const struct nft_expr *src,
+			     gfp_t gfp)
 {
 	struct nft_counter_percpu_priv *priv = nft_expr_priv(src);
 	struct nft_counter_percpu_priv *priv_clone = nft_expr_priv(dst);
@@ -234,7 +235,7 @@ static int nft_counter_clone(struct nft_
 
 	nft_counter_fetch(priv, &total);
 
-	cpu_stats = alloc_percpu_gfp(struct nft_counter, GFP_ATOMIC);
+	cpu_stats = alloc_percpu_gfp(struct nft_counter, gfp);
 	if (cpu_stats == NULL)
 		return -ENOMEM;
 
